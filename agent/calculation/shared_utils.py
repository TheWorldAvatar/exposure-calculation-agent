# functions that are shared between calculation types
from agent.calculation.calculation_input import CalculationInput
from shapely import wkt
from shapely.ops import transform
from pyproj import Transformer
from agent.utils import constants
from agent.utils.stack_configs import BLAZEGRAPH_URL, ONTOP_URL, ONTOP_CLIENT
from twa import agentlogging
import re
from agent.utils.postgis_client import postgis_client
from psycopg2.extras import execute_values
from agent.utils.stack_gateway import stack_clients_view
from pathlib import Path
from agent.utils.constants import METRE_SQUARED

logger = agentlogging.get_logger('dev')

rdf_type_to_unit = {
    constants.TRAJECTORY_COUNT: '',
    constants.TRAJECTORY_AREA: METRE_SQUARED
}


def instantiate_result_ontop(subject_to_value_dict: dict = None, calculation_input: CalculationInput = None):
    with postgis_client.connect() as conn:
        with conn.cursor() as cur:
            create_table = """
            CREATE TABLE IF NOT EXISTS exposure_result (
                id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                subject TEXT,
                exposure TEXT,
                calculation TEXT,
                value double precision,
                unit TEXT,
                CONSTRAINT exposure_result_constraint UNIQUE (subject, exposure, calculation)
            );
            """
            cur.execute(create_table)

            data = []

            if calculation_input.calculation_metadata.rdf_type not in constants.TRAJECTORY_TYPES:
                insert_query = """
                    INSERT INTO exposure_result (subject, exposure, calculation, value, unit)
                    VALUES %s
                    ON CONFLICT (subject, exposure, calculation)
                    DO UPDATE SET value = EXCLUDED.value,
                                  unit = EXCLUDED.unit
                """

                for subject, value in subject_to_value_dict.items():
                    data.append((subject, calculation_input.exposure,
                                calculation_input.calculation_metadata.iri, value.value, value.unit))
            else:
                # trajectory case, only one subject
                data = [(calculation_input.subject, calculation_input.exposure,
                         calculation_input.calculation_metadata.iri, rdf_type_to_unit[calculation_input.calculation_metadata.rdf_type])]

                insert_query = """
                    INSERT INTO exposure_result (subject, exposure, calculation, unit)
                    VALUES %s
                    ON CONFLICT DO NOTHING
                """

            execute_values(cur, insert_query, data)

    # upload mapping only if it has not been uploaded
    _upload_ontop_mapping(calculation_input=calculation_input)


def _upload_ontop_mapping(calculation_input: CalculationInput):
    from agent.utils.kg_client import kg_client

    # just picking a random subject to check
    if isinstance(calculation_input.subject, list):
        subject_to_check = calculation_input.subject[0]
    else:
        subject_to_check = calculation_input.subject

    query = f"""
    SELECT ?derivation
    WHERE {{
        ?derivation <{constants.IS_DERIVED_FROM}> <{subject_to_check}>;
            <{constants.IS_DERIVED_FROM}> <{calculation_input.exposure}>.
        ?exposure <{constants.BELONGS_TO}> ?derivation;
            <{constants.HAS_CALCULATION_METHOD}> <{calculation_input.calculation_metadata.iri}>.
    }}
    """
    query_result = kg_client.ontop_client.executeQuery(query)

    if query_result.isEmpty():
        ontop_mapping_path = Path('agent/calculation/resources/ontop.obda')

        path = stack_clients_view.java.nio.file.Paths.get(
            stack_clients_view.java.net.URI(ontop_mapping_path.resolve().as_uri()))
        ONTOP_CLIENT.updateOBDA(path)


def get_iri_to_point_dict(subject):
    from agent.utils.kg_client import kg_client

    iri_to_point_dict = {}
    transformer = Transformer.from_crs(
        "EPSG:4326", "EPSG:3857", always_xy=True)

    query_template = """
    SELECT ?subject ?wkt
    WHERE {{
        VALUES ?subject {{{values}}}.
        ?subject <http://www.opengis.net/ont/geosparql#asWKT> ?wkt.
    }}
    """

    logger.info(
        'Querying geometries of subjects, number of subjects: ' + str(len(subject)))

    query_list = []
    # submit queries in batches to avoid crashing ontop
    for chunk in _chunk_list(subject):
        values = " ".join(f"<{s}>" for s in chunk)
        query = query_template.format(values=values)
        query_list.append(query)

    for query in query_list:
        query_result = kg_client.remote_store_client.executeFederatedQuery(
            [BLAZEGRAPH_URL, ONTOP_URL], query)

        for i in range(query_result.length()):
            sub = query_result.getJSONObject(i).getString('subject')
            wkt_literal = query_result.getJSONObject(i).getString('wkt')

            # strip RDF literal IRI, i.e. ^^<http://www.opengis.net/ont/geosparql#wktLiteral>
            match = re.match(r'^"(.+)"\^\^<.+>$', wkt_literal)
            if match:
                geom = wkt.loads(match.group(1))
            else:
                geom = wkt.loads(wkt_literal)

            projected_geom = transform(transformer.transform, geom)
            iri_to_point_dict[sub] = projected_geom

    return iri_to_point_dict


def _chunk_list(values, chunk_size=10000):
    for i in range(0, len(values), chunk_size):
        yield values[i:i + chunk_size]
