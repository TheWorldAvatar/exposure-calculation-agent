# functions that are shared between calculation types
from agent.calculation.calculation_input import CalculationInput
from shapely import wkt
from shapely.ops import transform
from pyproj import Transformer
from agent.utils.stack_configs import BLAZEGRAPH_URL, ONTOP_URL, ONTOP_CLIENT
from twa import agentlogging
import re
from agent.utils.postgis_client import postgis_client
from psycopg2.extras import execute_values
from agent.utils.stack_gateway import stack_clients_view
from pathlib import Path

logger = agentlogging.get_logger('dev')


def instantiate_result_ontop(subject_to_value_dict: dict = None, calculation_input: CalculationInput = None):
    with postgis_client.connect() as conn:
        with conn.cursor() as cur:
            create_table = """
            CREATE TABLE IF NOT EXISTS exposure_result (
                id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                subject TEXT,
                exposure TEXT,
                calculation TEXT,
                value double precision,
                CONSTRAINT exposure_result_constraint UNIQUE (subject, exposure, calculation)
            );
            """
            cur.execute(create_table)

            data = []

            if subject_to_value_dict is not None:
                insert_query = """
                    INSERT INTO exposure_result (subject, exposure, calculation, value)
                    VALUES %s
                    ON CONFLICT (subject, exposure, calculation)
                    DO UPDATE SET value = EXCLUDED.value
                """

                for subject, value in subject_to_value_dict.items():
                    data.append((subject, calculation_input.exposure,
                                calculation_input.calculation_metadata.iri, value))
            else:
                data = [(calculation_input.subject, calculation_input.exposure,
                         calculation_input.calculation_metadata.iri)]

                insert_query = """
                    INSERT INTO exposure_result (subject, exposure, calculation)
                    VALUES %s
                    ON CONFLICT DO NOTHING
                """

            execute_values(cur, insert_query, data)
    ontop_mapping_path = Path('agent/calculation/resources/ontop.obda')

    path = stack_clients_view.java.nio.file.Paths.get(
        stack_clients_view.java.net.URI(ontop_mapping_path.resolve().as_uri()))
    ONTOP_CLIENT.updateOBDA(path)


def get_iri_to_point_dict(subject):
    from agent.utils.kg_client import kg_client

    iri_to_point_dict = {}
    transformer = Transformer.from_crs(
        "EPSG:4326", "EPSG:3857", always_xy=True)

    query_template = """
    SELECT ?subject ?wkt
    WHERE {{
        VALUES ?subject {{{values}}}.
        ?subject <http://www.opengis.net/ont/geosparql#asWKT> ?wkt.
    }}
    """

    logger.info(
        'Querying geometries of subjects, number of subjects: ' + str(len(subject)))

    query_list = []
    # submit queries in batches to avoid crashing ontop
    for chunk in _chunk_list(subject):
        values = " ".join(f"<{s}>" for s in chunk)
        query = query_template.format(values=values)
        query_list.append(query)

    for query in query_list:
        query_result = kg_client.remote_store_client.executeFederatedQuery(
            [BLAZEGRAPH_URL, ONTOP_URL], query)

        for i in range(query_result.length()):
            sub = query_result.getJSONObject(i).getString('subject')
            wkt_literal = query_result.getJSONObject(i).getString('wkt')

            # strip RDF literal IRI, i.e. ^^<http://www.opengis.net/ont/geosparql#wktLiteral>
            match = re.match(r'^"(.+)"\^\^<.+>$', wkt_literal)
            if match:
                geom = wkt.loads(match.group(1))
            else:
                geom = wkt.loads(wkt_literal)

            projected_geom = transform(transformer.transform, geom)
            iri_to_point_dict[sub] = projected_geom

    return iri_to_point_dict


def _chunk_list(values, chunk_size=10000):
    for i in range(0, len(values), chunk_size):
        yield values[i:i + chunk_size]
